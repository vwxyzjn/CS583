# Fun With Homography
In this project you will learn about homography matrices and use them to warp planar regions in images. The project consists of two major parts: rectification of a single planar region, and compositing of one planar region onto another.

All image parameters for skeleton functions are passed as 3D numpy arrays with shape (height, width, 3) for color images and (height, width, 1) for greyscale.

You will need to compute the eigendecomposition of a real-valued symmetric matrix. Numpy provides such a function: [Numpy Eigendecomposition](https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eigh.html). NOTE that this function returns the eigenvectors as columns, not rows as one might expect. The i'th eigenvector is evecs[:, i].

# Getting Started

## Environment Setup

We'll be using Python 3 for this assignment. To test your code on tux, you'll need to run:

```
pip3 install --user imageio
```

## Skeleton Code

Skeleton code has been linked below to get you started. Though it is not necessary, you are free to add functions as you see fit to complete the assignment. You are _not_, however, allowed to import additional libraries or submit separate code files. Everything you will need has been included in the skeleton. DO NOT change how the program reads parameters or loads the files. failure to follow these rule will result in a large loss of credit.

## Rectify Example

I've generated an example output with the image included in the skeleton kit using the following command:

```
python3 hw2.py rectify example_rectify_input.jpg 3 481 80 0 602 215 637 475 example_rectify_output.jpg
python3 hw2.py rectify example_rectify_input.jpg 3 481 80 0 602 215 637 475 --crop example_rectify_output_crop.jpg
```

## Composite Example

I've generated an example output with the images included in the skeleton kit using the following command:

```
python3 hw2.py composite example_panda.png example_laptop.png 100 520 50 300 280 259 325 460 example_mask.jpg example_composite_output.jpg
```

## Testing Correctness

I've provided a unit test for _some_ of the skeleton code that should help guide you in verifying the correctness of your program. To run it, execute:

```
python3 hw2_test.py -v
```

For more information about unit tests, see the [Python unittest documentation](https://docs.python.org/3/library/unittest.html).


# Submission

All of your code should be in a single file called `hw2.py`. Be sure to try to write something for each function. If your program errors on run you will loose many, if not all, points.

In addition to your code, you _must_ include the following items:

* An example of a rectified image that you took yourself. Call the source file `own_rectify_input.jpg` and the result `own_rectify_result.jpg`.
* An example of a composite that you generated by two images you took yourself. Call the source files `own_composite_input_1.jpg` and `own_composite_input_2.jpg` and the result file `own_composite_result.jpg`.
* A  `ReadMe.pdf` with the following items with a description of your experiments (e.g., changing parameters and showing their effects on the results, include lots of pictures) and a short discussion of what you struggled with, if anything. If you didn't complete the assignment or there is a serious bug in your code, indicate it here. If you believe your code is awesome, just say so. If you did extra credit, discuss it in this file as well.

Call your python file `hw2.py` and zip it, along with your example images and `ReadMe.pdf`, into an archive called `DREXELID_hw_2.zip` where `DREXELID` is your `abc123` alias. DO NOT include _any_ other files.

# Grading
All submissions will be graded by a program run on the [tux cluster](https://www.cs.drexel.edu/Account/Account.html). The grader is similar to the provided unit test, but will use different input and outputs. It is your responsibility to ensure your submission can be run on the tux cluster (if you follow the above instructions, it will!).

To avoid runtime errors:
* do no import any libraries (this is a requirement)
* do not rely on environment variables
* do not hard code any paths into your program

The assignment is worth 50 points and will be graded as follows:
* [10 pts]: build_A Homography Functions.
* [10 pts]: compute_H Homography Functions.
* [5 pts]: Proper warp_homography function
* [5 pts]: Implement and use bilinear interpolation for pixel color lookup.
* [5 pts]: Blending. Implement linear blending between two images using a mask (blend_with_mask).
* [5 pts]: Rectify and Composite Functions. Call the correct functions implemented above to rectify and composite images.
* [5 pts]: Demonstrate your code by rectifying at least one image of your choosing and compositing one image pair of your choosing.
* [5 pts]:  Include the report PDF described above. 

Extra Credit Options:
* [10 pts]: Implement Laplacian pyramid blending instead of linear blending. You may import and use scipy's convolution and/or image blurring functions to compute the pyramids.
* [10 pts]: Implement planar mosaicing.
* [5 pts]: Make warp_homography run faster usinga series of numpy array operations as opposed to a for loop (hint: Read about numpy broadcasting rules and reshaping operations, and lookup Look up numpy.mgrid / meshgrid.)
* [? pts]: Do something really interesting.
You must show the results of your code for each extra credit portion.
